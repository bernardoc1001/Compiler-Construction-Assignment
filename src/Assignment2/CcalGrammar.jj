/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CcalGrammar.jj */
/*@egen*//* ======== Section 1: Options ========== */
options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
  //todo MULTI = true;
  //todo VISITOR = true;
}

/* ======== Section 2: User Code ======== */

// This section 2 (from PARSER_BEGIN(CCALParser) to PARSER_END(CCALParser))
//was taken from/based on David Sinclair's notes

PARSER_BEGIN(CCALParser)

import java.io.*;
import java.util.*;


public class CCALParser/*@bgen(jjtree)*/implements CCALParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTCCALParserState jjtree = new JJTCCALParserState();

/*@egen*/
  //public static Hashtable ST = new Hashtable();

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    String temp;
    //STC temp2;


    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    CCALParser parser = new CCALParser(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");

    /*
    System.out.println();
    System.out.println("Symbol Table:");

    Enumeration t = ST.keys();

    while (t.hasMoreElements())
    {
      temp = (String)t.nextElement();
      temp2 = (STC)ST.get(temp);
      System.out.println(temp);
      if (temp2.type != null)
      {
        System.out.println(" type = " + temp2.type);
      }
      if (temp2.value != null)
      {
        System.out.println(" value = " + temp2.value);
      }
    }

    System.out.println();
    System.out.println("Program:");
    PrintVisitor pv = new PrintVisitor();
    root.jjtAccept(pv, null);

    System.out.println();
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);
    */
  }
}


PARSER_END(CCALParser)

/* ======== Section 3: Token Definitions === */
TOKEN_MGR_DECLS :
{
    //These variables are stored in the CCALParserTokenManager class,
    //which is generated by javacc.
    //We will check the value for bracketNesting in that class in our
    //program() production rule

	static int commentNesting = 0;
	static int bracketNesting = 0;
}

SKIP : //Ignoring spaces/tabs/mewlines
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"

}

SKIP : // Single line comments
{
	<"//" (~["\n"])* "\n"> //Taken from Geoff's old notes http://www.computing.dcu.ie/~hamilton/teaching/CA448/notes/JavaCClex2.pdf

}

SKIP : // Multi line comments
{
	"/*" {commentNesting++;} : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
            if (commentNesting == 0)
                SwitchTo(DEFAULT);
            }
  | <~[]>
}



 /* Keywords */
TOKEN :
{
	< VAR : "var" >
    | < CONST : "const" >
    | < RET : "return" >
    | < INT : "integer" >
    | < BOOL : "boolean" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < WHILE : "while" >
    | < BEGIN : "begin" >
    | < END : "end" >
    | < IS : "is" >
    | < SKI : "skip" >
}

 /* punctuation and binary operators */
/*Have square brackets to prevent following warning: Warning:  "," cannot be matched as a string literal token at line 96, column 9. It will be matched as  <token of kind 3>.*/
TOKEN :
{
	< COMMA : [","] >
    | < SEMI_COLON : [";"] >
    | < COLON : [":"] >
    | < ASSIGN : ["="] >
    | < PLUS_SIGN : ["+"] >
    | < MINUS_SIGN : ["-"] >
    | < NEGATE : ["~"] >
    | < OR : "||" >
    | < AND : "&&" >
    | < EQUALS : "==" >
    | < NOT_EQUALs : "!=" >
    | < LT : ["<"] >
    | < LTE : "<=" >
    | < GT : [">"] >
    | < GTE : ">=" >
}

// Define brackets and count them here. Will perform check when finished parsing file
TOKEN :
{
    < LBR : ["("] > { bracketNesting++; }
    | < RBR : [")"] > { bracketNesting--;}
}

/* Numbers and identifiers */
TOKEN :
{
    < NUM : (<ZERO_DIGIT>|((<NON_ZERO_DIGIT>)+ (<ZERO_DIGIT> | <NON_ZERO_DIGIT>)*)) >
    | < #NON_ZERO_DIGIT : ["1" - "9"] >
    | < ZERO_DIGIT : ["0"] >
    | < ID : (<LETTER>)+(<NUM>|"_"|<LETTER>)* >
    | < #LETTER : ["a" - "z", "A" -"Z"]>
}

/* Anything not recognised so far*/
TOKEN :
{
  < OTHER : ~[] >
}


/* ======== Section 4: The Grammar & Production Rules ========== */


SimpleNode program()          : {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    decl_list()
    function_list()
    main()
    {if( CCALParserTokenManager.bracketNesting != 0)
        throw new ParseException("There are " + CCALParserTokenManager.bracketNesting + " mismatched brackets in the code!");
    }/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void decl_list()           : {/*@bgen(jjtree) DeclList */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) DeclList */
    try {
/*@egen*/
    (decl() < SEMI_COLON > decl_list())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void decl()       : {/*@bgen(jjtree) Decl */
  SimpleNode jjtn000 = new SimpleNode(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Decl */
    try {
/*@egen*/
    var_decl()
    | const_decl()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void var_decl()          : {/*@bgen(jjtree) VarDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) VarDecl */
    try {
/*@egen*/
    <VAR> <ID><COLON>type()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void const_decl()            : {/*@bgen(jjtree) ConstDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConstDecl */
    try {
/*@egen*/
    <CONST> <ID><COLON>type() <ASSIGN> expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void function_list()               : {/*@bgen(jjtree) FunctionList */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) FunctionList */
    try {
/*@egen*/
    (function() function_list())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void function()           : {/*@bgen(jjtree) Function */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Function */
    try {
/*@egen*/
    type() <ID> <LBR>parameter_list()<RBR> <IS>
    decl_list()
    <BEGIN>
    statement_block()
    <RET> (<LBR> | { }) (expression() | { }) (<RBR> | { })<SEMI_COLON>
    <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void type()       : {/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <INT>|<BOOL>|<VOID>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void parameter_list()                : {/*@bgen(jjtree) ParameterList */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ParameterList */
    try {
/*@egen*/
    nemp_parameter_list()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//Performed Left Factorisation here
void nemp_parameter_list()                    : {/*@bgen(jjtree) NempParameterList */
  SimpleNode jjtn000 = new SimpleNode(JJTNEMPPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NempParameterList */
    try {
/*@egen*/
    <ID><COLON>type() nemp_parameter_list_prime()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void nemp_parameter_list_prime()                       : {/*@bgen(jjtree) NempParamterListPrime */
  SimpleNode jjtn000 = new SimpleNode(JJTNEMPPARAMTERLISTPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NempParamterListPrime */
    try {
/*@egen*/
    <COMMA> nemp_parameter_list()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void main()       : {/*@bgen(jjtree) Main */
  SimpleNode jjtn000 = new SimpleNode(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Main */
    try {
/*@egen*/
    <MAIN>
    <BEGIN>
    decl_list()
    statement_block()
    <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement_block()                 : {/*@bgen(jjtree) StatementBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) StatementBlock */
    try {
/*@egen*/
    statement() statement_block()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* Again perform Left Factorisation*/
void statement()            : {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <ID> statement_prime()
    | <BEGIN> statement_block() <END>
    | <IF> condition() <BEGIN> statement_block() <END>
        <ELSE> <BEGIN> statement_block() <END>
    | <WHILE> condition() <BEGIN> statement_block() <END>
    | <SKI><SEMI_COLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement_prime()                 : {/*@bgen(jjtree) StatementPrime */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) StatementPrime */
    try {
/*@egen*/
    <ASSIGN> expression()<SEMI_COLON>
    | <LBR> arg_list() <RBR> <SEMI_COLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

//expression is now a wrapper for fragment
void expression()            : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    //moved optional brackets here to have nested comments without conflicting with the
    //left bracket of arg_list. My bracket nesting checks will ensure there is no bracket mismatch
    (<LBR> | { }) fragment() (<RBR> |/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/ { })/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void binary_arith_op()                : {/*@bgen(jjtree) BinaryArithOp */
  SimpleNode jjtn000 = new SimpleNode(JJTBINARYARITHOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BinaryArithOp */
    try {
/*@egen*/
    <PLUS_SIGN>
    | <MINUS_SIGN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expression_alpha()	                 : {/*@bgen(jjtree) ExpressionAlpha */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONALPHA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ExpressionAlpha */
    try {
/*@egen*/
    binary_arith_op() fragment()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expression_beta()                 : {/*@bgen(jjtree) ExpressionBeta */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONBETA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ExpressionBeta */
    try {
/*@egen*/
    <LBR> arg_list() <RBR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void fragment_delta()                : {/*@bgen(jjtree) FragmentDelta */
  SimpleNode jjtn000 = new SimpleNode(JJTFRAGMENTDELTA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) FragmentDelta */
    try {
/*@egen*/

    <MINUS_SIGN>(<ID> | <NUM>) // I say or NUM here to define negative numbers
    | <NUM>
    | <TRUE>
    | <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void fragment_prime()                : {/*@bgen(jjtree) FragmentPrime */
  SimpleNode jjtn000 = new SimpleNode(JJTFRAGMENTPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) FragmentPrime */
    try {
/*@egen*/
    expression_alpha()fragment_prime()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void fragment()           : {/*@bgen(jjtree) Fragment */
  SimpleNode jjtn000 = new SimpleNode(JJTFRAGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Fragment */
    try {
/*@egen*/
    (<ID>|fragment_delta()) (expression_beta()|{ }) fragment_prime()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void condition()            : {/*@bgen(jjtree) Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Condition */
    try {
/*@egen*/
    (<LBR> |{ })condition_beta()condition_prime()(<RBR> |/*@bgen(jjtree)*/
                                                          {
                                                            jjtree.closeNodeScope(jjtn000, true);
                                                            jjtc000 = false;
                                                          }
/*@egen*/ { })/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ //Added optional brackets here
}

void condition_alpha()                 : {/*@bgen(jjtree) ConditionAlpha */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONALPHA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConditionAlpha */
    try {
/*@egen*/
    ((<OR>) | (<AND>)) condition()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void condition_beta()               : {/*@bgen(jjtree) ConditionBeta */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONBETA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } //Added possible brackets above in condition()
{/*@bgen(jjtree) ConditionBeta */
    try {
/*@egen*/
    <NEGATE>condition()
    | expression() comp_op() expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void condition_prime()                 : {/*@bgen(jjtree) ConditionPrime */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConditionPrime */
    try {
/*@egen*/
    condition_alpha()condition_prime()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void comp_op()         : {/*@bgen(jjtree) CompOp */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) CompOp */
    try {
/*@egen*/
    <EQUALS>
    | <NOT_EQUALs>
    | <LT>
    | <LTE>
    | <GT>
    | <GTE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arg_list()          : {/*@bgen(jjtree) ArgList */
  SimpleNode jjtn000 = new SimpleNode(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ArgList */
    try {
/*@egen*/
    nemp_arg_list()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*Perform Left Factoristation*/
void nemp_arg_list()              : {/*@bgen(jjtree) NempArgList */
  SimpleNode jjtn000 = new SimpleNode(JJTNEMPARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NempArgList */
    try {
/*@egen*/
    <ID> nemp_arg_list_prime()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void nemp_arg_list_prime()                   : {/*@bgen(jjtree) NempArgListPrime */
  SimpleNode jjtn000 = new SimpleNode(JJTNEMPARGLISTPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NempArgListPrime */
    try {
/*@egen*/
    <COMMA> nemp_arg_list()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ { }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}