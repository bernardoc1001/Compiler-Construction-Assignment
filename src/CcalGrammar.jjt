/* ======== Section 1: Options ========== */
options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
  MULTI = true;
  VISITOR = true;
}

/* ======== Section 2: User Code ======== */

// This section 2 (from PARSER_BEGIN(CCALParser) to PARSER_END(CCALParser))
//was taken from/based on David Sinclair's notes

PARSER_BEGIN(CCALParser)

import java.io.*;
import java.util.*;


public class CCALParser
{
  public static SymbolTable ST = new SymbolTable(SymbolTable.GLOBAL_SCOPE);

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    CCALParser parser = new CCALParser(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");
    System.out.println();
    System.out.println("================= Start of TypeChecking ========");
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);
    System.out.println("================= End of TypeChecking ==========");

    ST.printSymbolTable();
  }
}


PARSER_END(CCALParser)

/* ======== Section 3: Token Definitions === */
TOKEN_MGR_DECLS :
{
    //These variables are stored in the CCALParserTokenManager class,
    //which is generated by javacc.
    //We will check the value for bracketNesting in that class in our
    //program() production rule

	static int commentNesting = 0;
	static int bracketNesting = 0;
}

SKIP : //Ignoring spaces/tabs/mewlines
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"

}

SKIP : // Single line comments
{
	<"//" (~["\n"])* "\n"> //Taken from Geoff's old notes http://www.computing.dcu.ie/~hamilton/teaching/CA448/notes/JavaCClex2.pdf

}

SKIP : // Multi line comments
{
	"/*" {commentNesting++;} : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
            if (commentNesting == 0)
                SwitchTo(DEFAULT);
            }
  | <~[]>
}



 /* Keywords */
TOKEN :
{
	< VAR : "var" >
    | < CONST : "const" >
    | < RET : "return" >
    | < INT : "integer" >
    | < BOOL : "boolean" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < WHILE : "while" >
    | < BEGIN : "begin" >
    | < END : "end" >
    | < IS : "is" >
    | < SKI : "skip" >
}

 /* punctuation and binary operators */
/*Have square brackets to prevent following warning: Warning:  "," cannot be matched as a string literal token at line 96, column 9. It will be matched as  <token of kind 3>.*/
TOKEN :
{
	< COMMA : [","] >
    | < SEMI_COLON : [";"] >
    | < COLON : [":"] >
    | < ASSIGN : ["="] >
    | < PLUS_SIGN : ["+"] >
    | < MINUS_SIGN : ["-"] >
    | < NEGATE : ["~"] >
    | < OR : "||" >
    | < AND : "&&" >
    | < EQUALS : "==" >
    | < NOT_EQUALs : "!=" >
    | < LT : ["<"] >
    | < LTE : "<=" >
    | < GT : [">"] >
    | < GTE : ">=" >
}

// Define brackets and count them here. Will perform check when finished parsing file
TOKEN :
{
    < LBR : ["("] > { bracketNesting++; }
    | < RBR : [")"] > { bracketNesting--;}
}

/* Numbers and identifiers */
TOKEN :
{
    < NUM : (<ZERO_DIGIT>|((<NON_ZERO_DIGIT>)+ (<ZERO_DIGIT> | <NON_ZERO_DIGIT>)*)) >
    | < #NON_ZERO_DIGIT : ["1" - "9"] >
    | < ZERO_DIGIT : ["0"] >
    | < ID : (<LETTER>)+(<NUM>|"_"|<LETTER>)* >
    | < #LETTER : ["a" - "z", "A" -"Z"]>
}

/* Anything not recognised so far*/
TOKEN :
{
  < OTHER : ~[] >
}


/* ======== Section 4: The Grammar & Production Rules ========== */


SimpleNode program() #Program : { }
{
    decl_list()
    function_list()
    main()
    {if( CCALParserTokenManager.bracketNesting != 0)
        throw new ParseException("There are " + CCALParserTokenManager.bracketNesting + " mismatched brackets in the code!");
    }
    {return jjtThis;}
}



// Identifier taken from example ExprLang from notes. Added to make tracking
// the value of an ID easier
String identifier()  #ID : {Token t;}
{
  t = <ID> {jjtThis.value = t.image; return t.image;}
}

// Make a prod rule for numbers for similar reason to identifier
void number()  #Num : {Token t;}
{
  t = <NUM> {jjtThis.value = "integer"; }
}

//Follow the design pattern of Stms() from ExprLang example
void decl_list() #DeclList : { }
{
    (decl() <SEMI_COLON> decl_list())?
}


void decl() #Decl : { }
{
    var_decl()
    | const_decl()
}

void var_decl() #VarDecl : {Token t; String name;}
{
    <VAR> name = identifier()<COLON> t = type() {jjtThis.value = t.image;
                                                    ST.addToScope(name, new STC(t.image, name)); // add to current scope
                                                    }
}

void const_decl() #ConstDecl : {Token t; String name;}
{
    <CONST> name = identifier()<COLON> t = type() <ASSIGN> expression() {jjtThis.value = t.image;
                                                                            ST.addToScope(name, new STC(t.image, name)); // add to current scope
                                                                            }
}



void function_list() #FunctionList : { }
{
    (function() function_list())?
}

//Add to Syymbol table similar to VarDecl and ConstDecl
void function() #Function : {Token t; String name; }
{
    t = type() name = identifier() <LBR>parameter_list()<RBR> <IS> {ST.setCurrentScopeName(name); //Set the scope to the func name
                                                                       ST.addToScope(SymbolTable.GLOBAL_SCOPE,name , new STC(t.image, name)); // Add the function entry to the global scope
                                                                       }
    decl_list()
    <BEGIN>
    statement_block()
    <RET> (<LBR> | { }) (expression() | { }) (<RBR> | { })<SEMI_COLON>
    <END> {jjtThis.value = name; //changed from t.image to name
                ST.setCurrentScopeNameToPrevious(); //As we exit the function, reset scope to previous scope
              }
}

//Return token to make building Symbol table easier
Token type() #Type : { Token t; }
{
    t = <INT> {jjtThis.value = t.image; return t;}
    | t = <BOOL> {jjtThis.value = t.image; return t;}
    | t = <VOID> {jjtThis.value = t.image; return t;}
}

void parameter_list() #ParameterList : { }
{
    nemp_parameter_list()
    | { }
}

//Performed Left Factorisation here
void nemp_parameter_list() #NempParameterList : { }
{
    identifier()<COLON>type() nemp_parameter_list_prime()
}

void nemp_parameter_list_prime() #NempParameterListPrime: { }
{
    <COMMA> nemp_parameter_list()
    | { }
}

void main() #Main : { }
{
    {ST.setCurrentScopeName("main");} // set current scope to main
    <MAIN>
    <BEGIN>
    decl_list()
    statement_block()
    <END>
    {ST.setCurrentScopeNameToPrevious(); // As we exit the main function, reset scope to previous
    }
}

void statement_block() #StatementBlock : { }
{
    statement() statement_block()
    | { }
}

/* Again perform Left Factorisation*/
void statement() #Statement : { }
{
    identifier() statement_prime()
    | <BEGIN> statement_block() <END>
    | <IF> condition() <BEGIN> statement_block() <END>
        <ELSE> <BEGIN> statement_block() <END>
    | <WHILE> condition() <BEGIN> statement_block() <END>
    | <SKI><SEMI_COLON>
}

void statement_prime() #StatementPrime : { }
{
    <ASSIGN> expression()<SEMI_COLON>
    | <LBR> arg_list() <RBR> <SEMI_COLON>

}

//expression is now a wrapper for fragment
void expression() #Expression: { }
{
    //moved optional brackets here to have nested comments without conflicting with the
    //left bracket of arg_list. My bracket nesting checks will ensure there is no bracket mismatch
    (<LBR> | { }) fragment() (<RBR> | { })
}

//Make this node purely about the sign
void binary_arith_op() #BinaryArithOpSign : { }
{
    <PLUS_SIGN>
    | <MINUS_SIGN>
}

void expression_alpha()	#void : { }
{
    binary_arith_op() fragment() #BinaryArithOp(2) // Binary Sign, RHS
}

void expression_beta() #ExpressionBeta : { }
{
    <LBR> arg_list() <RBR>
}

void fragment_delta() #FragmentDelta : { }
{

    <MINUS_SIGN>(identifier() | number()) // I say or NUM here to define negative numbers
    | number()
    | <TRUE>
    | <FALSE>
}

void fragment_prime() #FragmentPrime : { }
{
    expression_alpha()fragment_prime()
    | { }
}

void fragment() #Fragment : { }
{
    (identifier()|fragment_delta()) (expression_beta()|{ }) fragment_prime()
}

void condition() #Condition : { }
{
    (<LBR> |{ })condition_beta()condition_prime()(<RBR> | { }) //Added optional brackets here
}

void condition_alpha() #ConditionAlpha : { }
{
    ((<OR>) | (<AND>)) condition()
}

void condition_beta() #ConditionBeta: { } //Added possible brackets above in condition()
{
    <NEGATE>condition()
    | expression() comp_op() expression()
}

void condition_prime() #ConditionPrime : { }
{
    condition_alpha()condition_prime()
    | { }
}

void comp_op() #CompOp : { }
{
    <EQUALS>
    | <NOT_EQUALs>
    | <LT>
    | <LTE>
    | <GT>
    | <GTE>
}

void arg_list() #ArgList : { }
{
    nemp_arg_list()
    | { }
}

/*Perform Left Factoristation*/
void nemp_arg_list() #NempArgList : { }
{
    identifier() nemp_arg_list_prime()
}

void nemp_arg_list_prime() #NempArgListPrime : { }
{
    <COMMA> nemp_arg_list()
    | { }
}

