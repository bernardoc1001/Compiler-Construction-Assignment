/* ======== Section 1: Options ========== */
options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}

/* ======== Section 2: User Code ======== */

PARSER_BEGIN(CCALTokeniser)

public class CCALTokeniser{
	public static void main(String args[]) {
		CCALTokeniser tokeniser;
		if(args.length == 0) {
			System.out.println("Reading from the standard input:");
			tokeniser = new CCALTokeniser(System.in);
		}
		else if(args.length == 1) {
	    	try {
				tokeniser = new CCALTokeniser(new java.io.FileInputStream(args[0]));
	        } catch (java.io.FileNotFoundException e) {
	            System.err.println("File " + args[0]  + " not found.");
	            return;
	        }
		}
	    else{
	        System.out.println("SLP Tokeniser:  Usage is one of:");
            System.out.println("         java CCALTokeniser < inputfile");
            System.out.println("OR");
            System.out.println("         java CCALTokeniser inputfile");
			return;
	    }

	    /* Read tokens and print until EOF */
		for(Token t = getNextToken(); t.kind != EOF; t = getNextToken()) {
			// Print out the actual text for the constants, identifiers etc
			if(t.kind == Num) {
				System.out.print("Number");
				System.out.print("("+t.image+") ");
			}
			else if(t.kind == ID)
			{
				System.out.print("Identifier");
				System.out.print("("+t.image+") ");
			}
			else {
				System.out.print(t.image+" ");
			}
		}
	}
}

PARSER_END(CCALTokeniser)

/* ======== Section 3: Token Definitions === */
TOKEN_MGR_DECLS :
{
	static int commentNesting = 0;
}

SKIP : /* COMMENTS */ /*TODO ADD IN OTHER KIND OF COMMENTS*/
{
	"/*" { commentNesting++; }
  | "*/" { commentNesting--;
  		   if(commentNesting == 0)
  		   		SwitchTo(DEFAULT);
  		 }
  | <~[]> 
}

 /* Keywords */
TOKEN :
{
	< VAR : "var" >
| 	< CONST : "const" >
| 	< RET : "return" >
| 	< INT : "integer" >
| 	< BOOL : "boolean" >
| 	< VOID : "void" >
| 	< MAIN : "main" >
|  	< IF : "if" >
|  	< ELSE : "else" >
| 	< TRUE : "true" >
| 	< FALSE : "false" >
| 	< WHILE : "while" >
|  	< BEGIN : "begin" >
| 	< END : "end" >
|  	< IS : "is" >
| 	< SKI : "skip" >
}

 /* punctuation and binary operators */
/*Have square brackets to prevent following warning: Warning:  "," cannot be matched as a string literal token at line 96, column 9. It will be matched as  <token of kind 3>.*/
TOKEN :
{
	< COMMA : [","] >
| 	< SCOLON : [";"] > 
| 	< COLON : [":"] >
| 	< ASSIGN : ["="] >
| 	< LBR : ["("] >
|  	< RBR : [")"] >
| 	< PLUS_SIGN : ["+"] >
| 	< MINUS_SIGN : ["-"] >
| 	< NEGATE : ["~"] >
|  	< OR : "||" >
|  	< AND : "&&" >
| 	< EQUALS : "==" >
| 	< NOT_EQUALs : "!=" >
| 	< LT : ["<"] >
|  	< LTE : "<=" >
| 	< GT : [">"] >
| 	< GTE : ">=" >  
}

/* Numbers and identifiers */
TOKEN :
{
  < NUM : (<ZERO_DIGIT>|((<NON_ZERO_DIGIT>)+ (<ZERO_DIGIT> | <NON_ZERO_DIGIT>)*)) >
| < #NON_ZERO_DIGIT : ["1" - "9"] >
| < ZERO_DIGIT : ["0"] >
| < ID : (<LETTER>)+(<NUM>|"_"|<LETTER>)* >
| < #LETTER : ["a" - "z", "A" -"Z"]>
}

/* Anything not recognised so far*/
TOKEN :
{
  < OTHER : ~[] >
}






