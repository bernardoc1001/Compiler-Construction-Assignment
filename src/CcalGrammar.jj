/* ======== Section 1: Options ========== */
options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}

/* ======== Section 2: User Code ======== */

// This section 2 (from PARSER_BEGIN(CCALParser) to PARSER_END(CCALParser))
//was taken from / based on David Sinclair's notes

PARSER_BEGIN(CCALParser)

public class CCALParser {
    public static void main(String args[]) {
        CCALParser parser;
        if (args.length == 0) {
            System.out.println("CCAL Parser:  Reading from standard input . . .");
            parser = new CCALParser(System.in);
        } else if (args.length == 1) {
            System.out.println("CCAL Parser:  Reading from file " + args[0] + " . . .");
            try {
                parser = new CCALParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("CCAL Parser:  File " + args[0] + " not found.");
                return;
            }
        } else {
            System.out.println("CCAL Parser:  Usage is one of:");
            System.out.println("         java CCALParser < inputfile");
            System.out.println("OR");
            System.out.println("         java CCALParser inputfile");
            return;
        }

        try {
            parser.program();
            System.out.println("CCAL Parser: CCAL program parsed successfully.");
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println("CCAL Parser:  Encountered errors during parse.");
        }
    }
}

PARSER_END(CCALParser)

/* ======== Section 3: Token Definitions === */
TOKEN_MGR_DECLS :
{
    //These variables are stored in the CCALParserTokenManager class,
    //which is generated by javacc.
    //We will check the value for bracketNesting in that class in our
    //program() production rule

	static int commentNesting = 0;
	static int bracketNesting = 0;
}

SKIP : //Ignoring spaces/tabs/mewlines
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"

}

SKIP : // Single line comments
{
	<"//" (~["\n"])* "\n"> //Taken from Geoff's old notes http://www.computing.dcu.ie/~hamilton/teaching/CA448/notes/JavaCClex2.pdf

}

SKIP : // Multi line comments
{
	"/*" {commentNesting++;} : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
            if (commentNesting == 0)
                SwitchTo(DEFAULT);
            }
  | <~[]>
}



 /* Keywords */
TOKEN :
{
	< VAR : "var" >
| 	< CONST : "const" >
| 	< RET : "return" >
| 	< INT : "integer" >
| 	< BOOL : "boolean" >
| 	< VOID : "void" >
| 	< MAIN : "main" >
|  	< IF : "if" >
|  	< ELSE : "else" >
| 	< TRUE : "true" >
| 	< FALSE : "false" >
| 	< WHILE : "while" >
|  	< BEGIN : "begin" >
| 	< END : "end" >
|  	< IS : "is" >
| 	< SKI : "skip" >
}

 /* punctuation and binary operators */
/*Have square brackets to prevent following warning: Warning:  "," cannot be matched as a string literal token at line 96, column 9. It will be matched as  <token of kind 3>.*/
TOKEN :
{
	< COMMA : [","] >
| 	< SEMI_COLON : [";"] > 
| 	< COLON : [":"] >
| 	< ASSIGN : ["="] >
| 	< PLUS_SIGN : ["+"] >
| 	< MINUS_SIGN : ["-"] >
| 	< NEGATE : ["~"] >
|  	< OR : "||" >
|  	< AND : "&&" >
| 	< EQUALS : "==" >
| 	< NOT_EQUALs : "!=" >
| 	< LT : ["<"] >
|  	< LTE : "<=" >
| 	< GT : [">"] >
| 	< GTE : ">=" >  
}

// Define brackets and count them here. Will perform check when finished parsing file
TOKEN :
{
    < LBR : ["("] > { bracketNesting++; }
    | < RBR : [")"] > { bracketNesting--;}
}

/* Numbers and identifiers */
TOKEN :
{
  < NUM : (<ZERO_DIGIT>|((<NON_ZERO_DIGIT>)+ (<ZERO_DIGIT> | <NON_ZERO_DIGIT>)*)) >
| < #NON_ZERO_DIGIT : ["1" - "9"] >
| < ZERO_DIGIT : ["0"] >
| < ID : (<LETTER>)+(<NUM>|"_"|<LETTER>)* >
| < #LETTER : ["a" - "z", "A" -"Z"]>
}

/* Anything not recognised so far*/
TOKEN :
{
  < OTHER : ~[] >
}


/* ======== Section 4: The Grammar & Production Rules ========== */


void program() : { }
{
  decl_list()
  function_list()
  main()
  {if( CCALParserTokenManager.bracketNesting != 0)
      throw new ParseException("There are " + CCALParserTokenManager.bracketNesting + " mismatched brackets in the code!");
    }
}

void decl_list()	: { }
{
  (decl() < SEMI_COLON > decl_list())?
}


void decl()	: { }
{
  var_decl()
| const_decl()
}

void var_decl()	: { }
{
  <VAR> <ID><COLON>type()
}

void const_decl()	: { }
{
  <CONST> <ID><COLON>type() <ASSIGN> expression()
}

void function_list()	: { }
{
  (function() function_list())?
}

void function()	: { }
{
  type() <ID> <LBR>parameter_list()<RBR> <IS>
  decl_list()
  <BEGIN>
  statement_block()
  <RET> (<LBR> | { }) (expression() | { }) (<RBR> | { })<SEMI_COLON>
  <END>
}

void type() : { }
{
  <INT>|<BOOL>|<VOID>
}

void parameter_list()	: { }
{
  nemp_parameter_list()
| { }
}

//Need to perform Left Factorisation
//Original:
//void nemp_parameter_list()	: { }
//{
//  <ID><COLON>type() | <ID><COLON>type() <COMMA> nemp_parameter_list()
//}

void nemp_parameter_list()	: { }
{
  <ID><COLON>type() nemp_parameter_list_prime()
}

void nemp_parameter_list_prime()	: { }
{
  <COMMA> nemp_parameter_list()
| { }
}

void main()	: { }
{
  <MAIN>
  <BEGIN>
  decl_list()
  statement_block()
  <END>
}

void statement_block()	: { }
{
  statement() statement_block()
| { }
}

/* Again perform Left Factorisation*/
void statement()	: { }
{
  <ID> statement_prime()
| <BEGIN> statement_block() <END>
| <IF> condition() <BEGIN> statement_block() <END>
	<ELSE> <BEGIN> statement_block() <END>
| <WHILE> condition() <BEGIN> statement_block() <END>
| <SKI><SEMI_COLON>
}

void statement_prime()	: { }
{
  <ASSIGN> expression()<SEMI_COLON>
| <LBR> arg_list() <RBR> <SEMI_COLON>

}

//expression is now a wrapper for fragment
void expression()	: { }
{
    //putting id here to remove lookahead
    //if this consumes id then we shouldn't call fragment
	(<LBR> | { }) fragment() (<RBR> | { })
}

void binary_arith_op()	: { }
{
  <PLUS_SIGN>
| <MINUS_SIGN>
}

void expression_alpha()	: { }
{
  binary_arith_op() fragment() //Have id here for same reason as in void expression()
}

void expression_beta(): { }
{
  <LBR> arg_list() <RBR>
}

void fragment_delta()	: { }
{

 <MINUS_SIGN>(<ID> | <NUM>) //TODO look at this later
| <NUM>
| <TRUE>
| <FALSE>
}

void fragment_prime(): { }
{
  expression_alpha()fragment_prime()
| { }
}

void fragment(): { }
{

  (<ID>|fragment_delta()) (expression_beta()|{ }) fragment_prime() //tidied up
}

void condition(): { }
{
  (<LBR> |{ })condition_beta()condition_prime()(<RBR> | { })
}

void condition_alpha(): { }
{
  ((<OR>) | (<AND>)) condition()
}

void condition_beta(): { } //Added possible brackets above
{
  <NEGATE>condition()
| expression() comp_op() expression()
}

void condition_prime(): { }
{
  condition_alpha()condition_prime()
| { }
}

void comp_op(): { }
{
  <EQUALS>
  | <NOT_EQUALs>
  |	<LT>
  |	<LTE>
  |	<GT>
  | <GTE>
}

void arg_list(): { }
{
  nemp_arg_list()
| { }
}

/*Perform Left Factoristation*/
void nemp_arg_list(): { }
{
  <ID> nemp_arg_list_prime()
}

void nemp_arg_list_prime(): { }
{
  <COMMA> nemp_arg_list()
| { }
}