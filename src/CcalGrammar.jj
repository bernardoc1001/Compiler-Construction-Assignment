/* ======== Section 1: Options ========== */
options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}

/* ======== Section 2: User Code ======== */

PARSER_BEGIN(CCALTokeniser)

public class CCALTokeniser{
	public static void main(String args[]) {
		CCALTokeniser tokeniser;
		if(args.length == 0) {
			System.out.println("Reading from the standard input:");
			tokeniser = new CCALTokeniser(System.in);
		}
		else if(args.length == 1) {
	    	try {
				tokeniser = new CCALTokeniser(new java.io.FileInputStream(args[0]));
	        } catch (java.io.FileNotFoundException e) {
	            System.err.println("File " + args[0]  + " not found.");
	            return;
	        }
		}
	    else{
	        System.out.println("SLP Tokeniser:  Usage is one of:");
            System.out.println("         java CCALTokeniser < inputfile");
            System.out.println("OR");
            System.out.println("         java CCALTokeniser inputfile");
			return;
	    }

	    /* Read tokens and print until EOF */
		for(Token t = getNextToken(); t.kind != EOF; t = getNextToken()) {
			// Print out the actual text for the constants, identifiers etc
			if(t.kind == Num) {
				System.out.print("Number");
				System.out.print("("+t.image+") ");
			}
			else if(t.kind == ID)
			{
				System.out.print("Identifier");
				System.out.print("("+t.image+") ");
			}
			else {
				System.out.print(t.image+" ");
			}
		}
	}
}

PARSER_END(CCALTokeniser)

/* ======== Section 3: Token Definitions === */
TOKEN_MGR_DECLS :
{
	static int commentNesting = 0;
}

SKIP : /* COMMENTS */ /*TODO ADD IN OTHER KIND OF COMMENTS*/
{
	"/*" { commentNesting++; }
  | "*/" { commentNesting--;
  		   if(commentNesting == 0)
  		   		SwitchTo(DEFAULT);
  		 }
  | <~[]> 
}

 /* Keywords */
TOKEN :
{
	< VAR : "var" >
| 	< CONST : "const" >
| 	< RET : "return" >
| 	< INT : "integer" >
| 	< BOOL : "boolean" >
| 	< VOID : "void" >
| 	< MAIN : "main" >
|  	< IF : "if" >
|  	< ELSE : "else" >
| 	< TRUE : "true" >
| 	< FALSE : "false" >
| 	< WHILE : "while" >
|  	< BEGIN : "begin" >
| 	< END : "end" >
|  	< IS : "is" >
| 	< SKI : "skip" >
}

 /* punctuation and binary operators */
/*Have square brackets to prevent following warning: Warning:  "," cannot be matched as a string literal token at line 96, column 9. It will be matched as  <token of kind 3>.*/
TOKEN :
{
	< COMMA : [","] >
| 	< SEMI_COLON : [";"] > 
| 	< COLON : [":"] >
| 	< ASSIGN : ["="] >
| 	< LBR : ["("] >
|  	< RBR : [")"] >
| 	< PLUS_SIGN : ["+"] >
| 	< MINUS_SIGN : ["-"] >
| 	< NEGATE : ["~"] >
|  	< OR : "||" >
|  	< AND : "&&" >
| 	< EQUALS : "==" >
| 	< NOT_EQUALs : "!=" >
| 	< LT : ["<"] >
|  	< LTE : "<=" >
| 	< GT : [">"] >
| 	< GTE : ">=" >  
}

/* Numbers and identifiers */
TOKEN :
{
  < NUM : (<ZERO_DIGIT>|((<NON_ZERO_DIGIT>)+ (<ZERO_DIGIT> | <NON_ZERO_DIGIT>)*)) >
| < #NON_ZERO_DIGIT : ["1" - "9"] >
| < ZERO_DIGIT : ["0"] >
| < ID : (<LETTER>)+(<NUM>|"_"|<LETTER>)* >
| < #LETTER : ["a" - "z", "A" -"Z"]>
}

/* Anything not recognised so far*/
TOKEN :
{
  < OTHER : ~[] >
}


/* ======== Section 4: The Grammar ========== */

void program() : { }
{
  decl_list()
  function_list()
  main()
}

/* TODO possibly fix this. is "?" represent "| epsilon". Do i make the list "?" */
void decl_list()	: { }
{
  (decl() < SEMI_COLON > decl_list())?
}


void decl()	: { }
{
  var_decl()
| const_decl()
}

void var_decl()	: { }
{
  <VAR> <ID><COLON>type()
}

void const_decl()	: { }
{
  <CONST> <ID><COLON>type() <ASSIGN> expression()
}

/* TODO possibly fix this. is "?" represent "| epsilon". Do i make the list "?" */
void function_list()	: { }
{
  (function() function_list())?
}

/*TODO check epsilon*/
void function()	: { }
{
  type() <ID> <LBR>parameter_list()<RBR> <IS>
  decl_list()
  <BEGIN>
  statement_block()
  <RET> <LBR> (expression())? <RBR><SEMI_COLON>
}

void type() : { }
{
  <INT>|<BOOL>|<VOID>
}

/*TODO check epsilon*/
void parameter_list()	: { }
{
  (nemp_parameter_list())?
}

void nemp_parameter_list()	: { }
{
  <ID><COLON>type() | <ID><COLON>type() <COMMA> nemp_parameter_list()
}

void main()	: { }
{
  <MAIN>
  <BEGIN>
  decl_list()
  statement_block()
  <END>
}

/*TODO check epsilon*/
void statement_block()	: { }
{
  (statement() statement_block())?
}

void statement()	: { }
{
  <ID> <ASSIGN> expression()<SEMI_COLON>
| <ID> <LBR> arg_list() <RBR> <SEMI_COLON>
| <BEGIN> statement_block() <END>
	<ELSE> <BEGIN> statement_block() <END>
| <WHILE> condition() <BEGIN> statement_block() <END>
| <SKI><SEMI_COLON>
}
// ORIGIONAL EXPRESSION: NEED TO REMOVE LEFT RECURSION
//void expression()	: { }
//{
//  fragment() binary_arith_op() fragment()
//| <LBR> expression() <RBR>
//| <ID> <LBR> arg_list() <RBR>
//| fragment()
//}
//
//void fragment()	: { }
//{
//  <ID>
//| <MINUS_SIGN><ID>
//| <NUM>
//| <TRUE>
//| <FALSE>
//| expression()
//}


//expression is now a wrapper for fragment
void expression()	: { }
{
	fragment()
}

void binary_arith_op()	: { }
{
  <PLUS_SIGN>
| <MINUS_SIGN>
}


//=========Start==============================
void expression_alpha()	: { }
{
  binary_arith_op() fragment()
}

void expression_beta(): { }
{
  <LBR> expression() <RBR>
| <ID> <LBR> arg_list() <RBR>
}

void fragment_delta()	: { }
{
  <ID>
| <MINUS_SIGN><ID>
| <NUM>
| <TRUE>
| <FALSE>
}

/*TODO check Epsilon*/
void fragment_prime(): { }
{
  (expression_alpha()fragment_prime())?
}

void fragment(): { }
{
  expression_beta()fragment_prime()
| fragment_delta()fragment_prime()
}
//=========End================================


// ORIGIONAL CONDITION STATEMENT: NEED TO REMOVE LEFT RECURSION
//void condition(): { }
//{
//  <NEGATE>condition()
//| <LBR> condition()<RBR>
//| expression() comp_op() expression()
//| condition() ((<OR>) | (<AND>)) condition()
//}


// I am using the following formula to remove left recursion
// Given:
// A --> A alpha | B
// Convert it to
// A -- > BA'
// A' -- > alpha A' | epsilon

void condition(): { }
{
  condition_beta()condition_prime()
}

void condition_alpha(): { }
{
  ((<OR>) | (<AND>)) condition()
}

void condition_beta(): { }
{
  <NEGATE>condition()
| <LBR> condition()<RBR>
| expression() comp_op() expression()
}

/*TODO check epsilon*/
void condition_prime(): { }
{
  (condition_alpha()condition_prime())?
}

void comp_op(): { }
{
  <EQUALS>
  | <NOT_EQUALs>
  |	<LT>
  |	<LTE>
  |	<GT>
  | <GTE>
}

/*TODO check epsilon*/
void arg_list(): { }
{
  (nemp_arg_list())?
}

void nemp_arg_list(): { }
{
  <ID>
| <ID> <COMMA> nemp_arg_list()
}