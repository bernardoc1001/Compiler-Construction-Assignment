/* ======== Section 1: Options ========== */
options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}

/* ======== Section 2: User Code ======== */



PARSER_BEGIN(CCALParser)

public class CCALParser {
    public static void main(String args[]) {
        CCALParser parser;
        if (args.length == 0) {
            System.out.println("CCAL Parser:  Reading from standard input . . .");
            parser = new CCALParser(System.in);
        } else if (args.length == 1) {
            System.out.println("CCAL Parser:  Reading from file " + args[0] + " . . .");
            try {
                parser = new CCALParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("CCAL Parser:  File " + args[0] + " not found.");
                return;
            }
        } else {
            System.out.println("CCAL Parser:  Usage is one of:");
            System.out.println("         java CCALParser < inputfile");
            System.out.println("OR");
            System.out.println("         java CCALParser inputfile");
            return;
        }

        try {
            parser.program();
            System.out.println("CCAL Parser: CCAL program parsed successfully.");
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println("CCAL Parser:  Encountered errors during parse.");
        }
    }
}

PARSER_END(CCALParser)

/* ======== Section 3: Token Definitions === */
TOKEN_MGR_DECLS :
{
	static int commentNesting = 0;
}

SKIP : //Ignoring spaces/tabs/mewlines
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"

}

SKIP : // Single line comments
{
	<"//" (~["\n"])* "\n"> //Taken from Geoff's old notes http://www.computing.dcu.ie/~hamilton/teaching/CA448/notes/JavaCClex2.pdf

}

SKIP : // Multi line comments
{
	"/*" {commentNesting++;} : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
            if (commentNesting == 0)
                SwitchTo(DEFAULT);
            }
  | <~[]>
}



 /* Keywords */
TOKEN :
{
	< VAR : "var" >
| 	< CONST : "const" >
| 	< RET : "return" >
| 	< INT : "integer" >
| 	< BOOL : "boolean" >
| 	< VOID : "void" >
| 	< MAIN : "main" >
|  	< IF : "if" >
|  	< ELSE : "else" >
| 	< TRUE : "true" >
| 	< FALSE : "false" >
| 	< WHILE : "while" >
|  	< BEGIN : "begin" >
| 	< END : "end" >
|  	< IS : "is" >
| 	< SKI : "skip" >
}

 /* punctuation and binary operators */
/*Have square brackets to prevent following warning: Warning:  "," cannot be matched as a string literal token at line 96, column 9. It will be matched as  <token of kind 3>.*/
TOKEN :
{
	< COMMA : [","] >
| 	< SEMI_COLON : [";"] > 
| 	< COLON : [":"] >
| 	< ASSIGN : ["="] >
| 	< LBR : ["("] >
|  	< RBR : [")"] >
| 	< PLUS_SIGN : ["+"] >
| 	< MINUS_SIGN : ["-"] >
| 	< NEGATE : ["~"] >
|  	< OR : "||" >
|  	< AND : "&&" >
| 	< EQUALS : "==" >
| 	< NOT_EQUALs : "!=" >
| 	< LT : ["<"] >
|  	< LTE : "<=" >
| 	< GT : [">"] >
| 	< GTE : ">=" >  
}

/* Numbers and identifiers */
TOKEN :
{
  < NUM : (<ZERO_DIGIT>|((<NON_ZERO_DIGIT>)+ (<ZERO_DIGIT> | <NON_ZERO_DIGIT>)*)) >
| < #NON_ZERO_DIGIT : ["1" - "9"] >
| < ZERO_DIGIT : ["0"] >
| < ID : (<LETTER>)+(<NUM>|"_"|<LETTER>)* >
| < #LETTER : ["a" - "z", "A" -"Z"]>
}

/* Anything not recognised so far*/
TOKEN :
{
  < OTHER : ~[] >
}


/* ======== Section 4: The Grammar & Production Rules ========== */


void program() : { }
{
  decl_list()
  function_list()
  main()
}

/* TODO possibly fix this. is "?" represent "| epsilon". Do i make the list "?" */
void decl_list()	: { }
{
  (decl() < SEMI_COLON > decl_list())?
}


void decl()	: { }
{
  var_decl()
| const_decl()
}

void var_decl()	: { }
{
  <VAR> <ID><COLON>type()
}

void const_decl()	: { }
{
  <CONST> <ID><COLON>type() <ASSIGN> expression()
}

/* TODO possibly fix this. is "?" represent "| epsilon". Do i make the list "?" */
void function_list()	: { }
{
  (function() function_list())?
}

void function()	: { }
{
  type() <ID> <LBR>parameter_list()<RBR> <IS>
  decl_list()
  <BEGIN>
  statement_block()
  <RET> function_nested_brackets()<SEMI_COLON>
  <END>
}

void function_nested_brackets():{}
{
    (<LBR> | { }) (expression() | { }) (<RBR> | { })
}

void type() : { }
{
  <INT>|<BOOL>|<VOID>
}

void parameter_list()	: { }
{
  nemp_parameter_list()
| { }
}

//Need to perform Left Factorisation
//Original:
//void nemp_parameter_list()	: { }
//{
//  <ID><COLON>type() | <ID><COLON>type() <COMMA> nemp_parameter_list()
//}

void nemp_parameter_list()	: { }
{
  <ID><COLON>type() nemp_parameter_list_prime()
}

void nemp_parameter_list_prime()	: { }
{
  <COMMA> nemp_parameter_list()
| { }
}

void main()	: { }
{
  <MAIN>
  <BEGIN>
  decl_list()
  statement_block()
  <END>
}

void statement_block()	: { }
{
  statement() statement_block()
| { }
}

/* Again perform Left Factorisation*/
void statement()	: { }
{
  <ID> statement_prime()
| <BEGIN> statement_block() <END>
| <IF> condition() <BEGIN> statement_block() <END>
	<ELSE> <BEGIN> statement_block() <END>
| <WHILE> condition() <BEGIN> statement_block() <END>
| <SKI><SEMI_COLON>
}

void statement_prime()	: { }
{
  <ASSIGN> expression()<SEMI_COLON>
| <LBR> arg_list() <RBR> <SEMI_COLON>

}


// ORIGIONAL EXPRESSION: NEED TO REMOVE LEFT RECURSION
//void expression()	: { }
//{
//  fragment() binary_arith_op() fragment()
//| <LBR> expression() <RBR>
//| <ID> <LBR> arg_list() <RBR>
//| fragment()
//}
//
//void fragment()	: { }
//{
//  <ID>
//| <MINUS_SIGN><ID>
//| <NUM>
//| <TRUE>
//| <FALSE>
//| expression()
//}





/*
//expression is now a wrapper for fragment
void expression()	: { }
{
	fragment()
}

void binary_arith_op()	: { }
{
  <PLUS_SIGN>
| <MINUS_SIGN>
}


//=========Start==============================
void expression_alpha()	: { }
{
  binary_arith_op() fragment()
}

void expression_beta(): { }
{
  <LBR> expression() <RBR>
| <ID> <LBR> arg_list() <RBR>
}

void fragment_delta()	: { }
{
  <ID>
| <MINUS_SIGN><ID>
| <NUM>
| <TRUE>
| <FALSE>
}

void fragment_prime(): { }
{
  expression_alpha()fragment_prime()
| { }
}


// Not sure I've done id lookahead correctly here
void fragment(): { }
{
  expression_beta()fragment_prime()
| fragment_delta()fragment_prime()
}


//=========End================================

*/





// +++++++++++++++ Fresh Start +++++++++++++++++++++++++

 void expression() : {} {
    (<LBR>|{})expression_helper()(<RBR>|{})
 }

 void expression_helper() : {} {
    (<ID>|(fragment()))((binary_arith_op()(<ID>|(fragment()))|(<LBR>arg_list()<RBR>))|{})
 }

 void binary_arith_op() : {} {
    <PLUS_SIGN>
    | <MINUS_SIGN> 
 } 
 
 void fragment() : {} {
    <MINUS_SIGN> (<ID>|<NUM>)
    | <NUM>
    | <TRUE>
    | <FALSE>
 }

// +++++++++++++++ Fresh End +++++++++++++++++++++++++++









// ORIGIONAL CONDITION STATEMENT: NEED TO REMOVE LEFT RECURSION
//void condition(): { }
//{
//  <NEGATE>condition()
//| <LBR> condition()<RBR>
//| expression() comp_op() expression()
//| condition() ((<OR>) | (<AND>)) condition()
//}


// I am using the following formula to remove left recursion
// Given:
// A --> A alpha | B
// Convert it to
// A -- > BA'
// A' -- > alpha A' | epsilon


/*
void condition(): { }
{
  condition_beta()condition_prime()
}

void condition_alpha(): { }
{
  ((<OR>) | (<AND>)) condition()
}

void condition_beta(): { }
{
  <NEGATE>condition()
| <LBR> condition()<RBR>
| expression() comp_op() expression()
}

void condition_prime(): { }
{
  condition_alpha()condition_prime()
| { }
}
*/






//++++++++++++++ fresh start ++++++++++++++++
 void condition_helper() : {} {
    expression() comp_op() expression()
 }

 void condition() : {} {
    (<NEGATE>|{}) (<LBR>|{})condition_helper()(<RBR>|{})(((<OR> | <AND>) condition_helper())|{})
 }
//++++++++++++++ Fresh End ++++++++++++++++++









void comp_op(): { }
{
  <EQUALS>
  | <NOT_EQUALs>
  |	<LT>
  |	<LTE>
  |	<GT>
  | <GTE>
}

void arg_list(): { }
{
  nemp_arg_list()
| { }
}

/*Perform Left Factoristation*/
void nemp_arg_list(): { }
{
  <ID> nemp_arg_list_prime()
}

void nemp_arg_list_prime(): { }
{
  <COMMA> nemp_arg_list()
| { }
}